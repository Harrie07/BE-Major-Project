# .dockerignore (Create this file to speed up builds)
# Add this content to .dockerignore file:
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
data/
uploads/
outputs/
logs/
*.log

# Docker
Dockerfile*
docker-compose*.yml
.dockerignore

# Git
.git/
.gitignore
README.md
*.md

---

# BUILD OPTIMIZATION COMMANDS

# 1. CLEAN BUILD (First Time Only)
docker-compose down -v
docker system prune -a
docker-compose build --no-cache

# 2. FAST INCREMENTAL BUILDS (Normal Development)
docker-compose build
docker-compose up -d

# 3. REBUILD ONLY APP (Faster for Code Changes)
docker-compose build app worker
docker-compose up -d --no-deps app worker

# 4. VIEW BUILD PROGRESS
docker-compose build --progress=plain

# 5. PARALLEL BUILDS (Faster on Multi-Core)
docker-compose build --parallel

# 6. CHECK IMAGE SIZES (Optimize if Needed)
docker images | grep mumbai

---

# DEVELOPMENT WORKFLOW

# Terminal 1: Start Services
docker-compose up -d db redis minio titiler
sleep 10  # Wait for services to be ready
docker-compose up -d app worker

# Terminal 2: Watch Logs
docker-compose logs -f app

# Terminal 3: Watch Worker Logs  
docker-compose logs -f worker

# Terminal 4: Development Commands
# Enter app container for debugging
docker-compose exec app bash

# Run database migrations
docker-compose exec app alembic upgrade head

# Check Redis queue stats
docker-compose exec app python -c "
from app.services.queue_service import QueueService
import asyncio
qs = QueueService()
print(asyncio.run(qs.get_queue_stats()))
"

---

# PRODUCTION DEPLOYMENT

# 1. Build optimized production images
docker-compose -f docker-compose.yml -f docker-compose.prod.yml build

# 2. Start production stack
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 3. Health checks
curl -f http://localhost:8000/health
curl -f http://localhost:8001/health

---

# TROUBLESHOOTING COMMANDS

# Check service health
docker-compose ps

# Check container logs for errors
docker-compose logs app | grep ERROR
docker-compose logs worker | grep ERROR

# Check network connectivity
docker-compose exec app ping db
docker-compose exec app ping redis

# Test database connection
docker-compose exec app python -c "
from app.db.database import engine
try:
    with engine.connect() as conn:
        print('DB connection successful')
except Exception as e:
    print(f'DB connection failed: {e}')
"

# Test Redis connection
docker-compose exec app python -c "
from app.services.queue_service import QueueService
qs = QueueService()
print('Redis healthy:', qs.is_healthy())
"

# Check disk usage (important for build speed)
docker system df

# Clean up unused resources
docker system prune

# Remove only unused images (keep cache)
docker image prune